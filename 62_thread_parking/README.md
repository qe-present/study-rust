# Thread Parking 示例

本项目演示了 Rust 中的线程停车(parking)机制，这是一种线程同步技术，允许线程挂起和唤醒。

## 什么是线程停车?

线程停车是 Rust 标准库提供的一种底层同步原语，允许线程主动挂起自己，并在之后被其他线程唤醒。与条件变量相比，它更轻量、更底层。

## 核心概念

### thread::park()
- 挂起当前线程，使其进入等待状态
- 线程会保持阻塞，直到被 `unpark()` 唤醒
- 可以在循环中使用，等待特定条件满足

### thread::Thread::unpark()
- 唤醒指定的线程
- 如果线程已经在等待，立即唤醒
- 如果线程还未进入等待，设置一个"令牌"，下次调用 `park()` 时会立即返回

## 工作原理

线程停车机制类似于一个单元素的信号量:
- 每个线程都有一个内部的"停车令牌"(parking token)
- `unpark()` 会设置这个令牌(如果尚未设置)
- `park()` 会消耗这个令牌(如果可用)或等待直到令牌可用

## 使用场景

1. **实现自定义同步原语**: 在更高级别的同步原语(如通道、锁)的底层实现中使用
2. **简单的等待-通知模式**: 当线程需要等待某个条件满足时
3. **性能敏感的场景**: 相比条件变量，线程停车有更少的开销

## 代码示例

本示例演示了线程停车的基本用法:

### 示例流程

1. **线程1**启动并进入一个循环，等待某个条件(flag 变为 true)
2. 在每次循环中，线程1调用 `thread::park()` 挂起自己
3. **主线程**睡眠2秒后，将 flag 设置为 true
4. 主线程获取线程1的句柄，并调用 `unpark()` 唤醒它
5. 线程1被唤醒后，检查条件，发现满足后退出循环

### 关键点

```rust
while !flag2.load(Ordering::Relaxed) {
    println!("线程等待中...");
    thread::park(); // 挂起线程
    println!("线程被唤醒!");
}
```

- 使用 `while` 循环而不是 `if`，因为线程可能被虚假唤醒(spurious wakeup)
- 通过原子变量 `AtomicBool` 作为共享状态标志
- 使用 `crossbeam::scope` 管理线程生命周期

### 唤醒线程

```rust
let handle2 = handle.thread().clone();
scope.spawn(move |_| {
    println!("start");
    flag.store(true, Ordering::Relaxed);
    handle2.unpark(); // 唤醒线程
});
```

- 通过 `handle.thread()` 获取线程句柄
- 调用 `unpark()` 唤醒挂起的线程

## 与 Condition Variable 的区别

| 特性 | Thread Parking | Condition Variable |
|------|---------------|-------------------|
| API 复杂度 | 简单(仅 park/unpark) | 复杂(wait/notify) |
| 使用场景 | 底层实现、简单等待 | 复杂的等待-通知模式 |
| 是否关联锁 | 不需要 | 必须关联 Mutex |
| 效率 | 更高(系统调用更少) | 稍低 |

## 注意事项

1. **虚假唤醒**: 线程可能因为各种原因在没有 `unpark()` 的情况下被唤醒，所以应该始终在循环中检查条件
2. **令牌机制**: `unpark()` 可以在 `park()` 之前调用，这种情况下 `park()` 会立即返回
3. **线程句柄**: 需要通过 `JoinHandle::thread()` 获取线程句柄才能调用 `unpark()`
4. **性能**: 频繁的 park/unpark 会带来性能开销，应谨慎使用

## 运行测试

```bash
cargo test
```

## 总结

线程停车是 Rust 提供的一个轻量级、底层的线程同步机制。它非常适合用于实现其他同步原语，或在简单的等待-通知场景中使用。理解线程停车机制有助于深入了解 Rust 并发编程的底层原理。
